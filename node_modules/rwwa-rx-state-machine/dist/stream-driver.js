// ************************************************
// --------------- Typings polyfils ---------------
// ************************************************
"use strict";
var Rx = require("rx");
var Immutable = require("immutable");
// ***************************************************
// --------------- The main state loop ---------------
// ***************************************************
var SIGNAL_EMITTER$ = new Rx.Subject();
var LIVE_SIGNAL$ = SIGNAL_EMITTER$
    .mergeAll()
    .observeOn(Rx.Scheduler.currentThread);
var INITIAL_STATE = Immutable.Map({ '__drivers': Immutable.Map() });
var LIVE_STATE$ = LIVE_SIGNAL$.scan(RootDriver, INITIAL_STATE).observeOn(Rx.Scheduler.currentThread);
var ERROR$ = new Rx.Subject();
var connectedLiveState$ = connectAndReplay(LIVE_STATE$);
var connectedLiveSignal$ = connectAndReplay(LIVE_SIGNAL$);
var connectedError$ = connectAndReplay(ERROR$);
var SWITCHABLE_STATE$$ = new Rx.Subject();
var connectedSwitchedState$ = connectAndReplay(SWITCHABLE_STATE$$).switch();
SWITCHABLE_STATE$$.onNext(connectedLiveState$);
ERROR$.subscribe(function (errorEvent) {
    var error = errorEvent.error;
    console && console.error(error.stack || error);
});
// **********************************************
// --------------- Implementation ---------------
// **********************************************
var attachDriverSignal = createSignal('ATTACH DRIVER');
var resetStateSignal = createSignal('RESET STATE');
function getOrDefault(key, state, otherwise) {
    return state.get(key) || otherwise;
}
function splitPath(inputPath) {
    var fullPath = inputPath.split('.');
    var path = fullPath.slice(0, -1);
    var key = fullPath[fullPath.length - 1];
    return [path, key];
}
function getChildDriverList(state) {
    return getOrDefault('__drivers', state, Immutable.Map());
}
exports.compositeDriver = function (state, signal, onError) {
    var drivers = getChildDriverList(state);
    return drivers.reduce(function (state, driver, key) {
        var innerState = state.get(key);
        try {
            var newState = driver(innerState, signal, onError);
            return state.set(key, newState);
        }
        catch (ex) {
            onError(innerState)(ex);
        }
        return state;
    }, state);
};
var onError = function (signal) { return function (state) { return function (error) { ERROR$.onNext({ signal: signal, state: state, error: error }); }; }; };
function RootDriver(state, signal) {
    try {
        switch (signal.tag) {
            case attachDriverSignal:
                var data = signal.data;
                var _a = splitPath(signal.data.path), path = _a[0], key = _a[1];
                var pathState = state.getIn(path);
                var driverList = getChildDriverList(pathState);
                if (driverList) {
                    var updatePathState = pathState.set('__drivers', driverList.set(key, data.driver));
                    if (data.driver === exports.compositeDriver) {
                        updatePathState = updatePathState.setIn([key, '__drivers'], Immutable.Map());
                    }
                    var updatedState = state.setIn(path, updatePathState);
                    return exports.compositeDriver(updatedState, signal);
                }
                throw "cannot add driver to " + path.join('.') + " as it is not a composite driver";
            case resetStateSignal:
                return INITIAL_STATE;
            default:
                return exports.compositeDriver(state, signal, onError(signal));
        }
    }
    catch (ex) {
        onError(signal)(state)(ex);
    }
    return state;
}
function connectAndReplay(input$) {
    // casting to any is a bit of a hack, but it seems the typescript definition is missing
    var replay$ = input$.replay(null, 1);
    replay$.connect();
    return replay$;
}
function createSignal(name) {
    var emitter = new Rx.Subject();
    SIGNAL_EMITTER$.onNext(emitter);
    var signalFactory = function (data) {
        // this is a bit funky, we assign the factory function as the tag of the signal
        var signal = {
            tag: signalFactory,
            name: name,
            data: data
        };
        emitter.onNext(signal);
    };
    signalFactory.signal$ = emitter;
    return signalFactory;
}
exports.createSignal = createSignal;
function attachDriver(data) {
    attachDriverSignal(data);
    var _a = splitPath(data.path), path = _a[0], key = _a[1];
    return connectedSwitchedState$
        .where(function (root) { return root && root.hasIn(path); })
        .select(function (root) { return root.getIn(path); })
        .where(function (parentNode) { return parentNode && parentNode.has(key); })
        .select(function (parentNode) { return parentNode.get(key); })
        .distinctUntilChanged();
}
exports.attachDriver = attachDriver;
function __resetState__() {
    resetStateSignal();
}
exports.__resetState__ = __resetState__;
exports.__internal = {
    SWITCHABLE_STATE$$: SWITCHABLE_STATE$$,
    connectedLiveState$: connectedLiveState$,
    connectedLiveSignal$: connectedLiveSignal$,
    connectedError$: connectedError$,
};
exports.CompositeDriver = exports.compositeDriver;
exports.state$ = connectedSwitchedState$;
exports.signal$ = connectedLiveSignal$;
exports.error$ = connectedError$;
// Backwards compatibility aliases
exports.createIntent = createSignal;
exports.DynamicCompositeDriver = exports.compositeDriver;
